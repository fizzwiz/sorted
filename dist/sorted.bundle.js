!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.sorted=e():t.sorted=e()}(self,(()=>(()=>{"use strict";var t={d:(e,r)=>{for(var s in r)t.o(r,s)&&!t.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:r[s]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{ArrayQueue:()=>f,AsyncCollection:()=>l,Classifier:()=>w,Collection:()=>h,ORDER:()=>y,Queue:()=>u,SORTER:()=>d,SortedArray:()=>m,TrueSet:()=>p});class r{parent;last;length;constructor(t=void 0,e=void 0){this.parent=t,this.last=e,this.length=t?t.length+1:void 0!==e?1:0}static of(...t){return(new r).along(t)}isEmpty(){return 0===this.length}isRoot(){return void 0===this.parent}add(t){return new r(this.isEmpty()?void 0:this,t)}along(t){let e=this;for(let r of t)e=e.add(r);return e}across(t){const e=this,r=new c;return r[Symbol.iterator]=function*(){for(let r of t)yield e.add(r)},r}toArray(t=this.length,e=t=>t){t=Math.min(t,this.length);const r=new Array(t);let s=this;for(;t>0;)r[t-1]=e(s.last),s=s.parent,t--;return r}}class s{[Symbol.asyncIterator](){throw"abstract method!"}static of(...t){const e=new s;return e[Symbol.asyncIterator]=async function*(){for(const e of t)yield await e},e}static as(t){let e;return void 0===t?s.of():t instanceof s?t:(t[Symbol.iterator]||t[Symbol.asyncIterator]?(e=new s,e[Symbol.asyncIterator]=async function*(){for(const e of t)yield e}):(e=new s,e[Symbol.asyncIterator]=async function*(){yield await t}),e)}async toArray(){const t=[];for await(const e of this)t.push(e);return t}async equals(t){return s.equal(this,t)}static along(t,e){const r=new s;return r[Symbol.asyncIterator]=async function*(){let r=t;for(;null!=r;)yield r,r=await e(r)},r}static async equal(t,e){if("string"==typeof t||!c.isIterable(t)&&!s.isAsyncIterable(t)||"string"==typeof e||!c.isIterable(e)&&!s.isAsyncIterable(e))return t===e;{const r=s.as(t)[Symbol.asyncIterator](),n=s.as(e)[Symbol.asyncIterator]();for(;;){const t=await r.next(),e=await n.next();if(t.done||e.done)return t.done===e.done;if(!await s.equal(t.value,e.value))return!1}}}static isAsyncIterable(t){return null!=t&&"function"==typeof t[Symbol.asyncIterator]}if(t=t=>void 0!==t){const e=this,r=new s;return r[Symbol.asyncIterator]=async function*(){let r=0;for await(const s of e)await t(s,r++)&&(yield s)},r}sthen(t){const e=this,r=new s;return r[Symbol.asyncIterator]=async function*(){let r=0;for await(const s of e)yield await t(s,r++)},r}else(t=void 0){return void 0===t?s.else(this):s.else([this,s.as(t)])}static else(t){const e=new s;return e[Symbol.asyncIterator]=async function*(){for await(const e of s.as(t)){const t=s.as(e);for await(const e of t)yield e}},e}which(t){return this.if(t)}when(t,e=!0,r=e){return s.when(this,t,e,r)}static when(t,e,r=!0,n=r){if(void 0===e){const e={};return e[Symbol.asyncIterator]=async function*(){for await(const e of t)yield e},s.as(e)}if("number"==typeof e){const t=e;e=(e,r)=>r===t}const i=new s;return i[Symbol.asyncIterator]=r?async function*(){let r=0,s=!1;for await(const i of t)s?yield i:await e(i,r)&&(s=!0,n&&(yield i)),r++}:async function*(){let r=0,s=!1;for await(const i of t){if(s)break;await e(i,r)?(s=!0,n&&(yield i)):yield i,r++}},i}match(t=void 0){return void 0===t?s.match(this):s.match(this,s.as(t))}static match(...t){const e=new s,r=t.map((t=>s.as(t)));return e[Symbol.asyncIterator]=async function*(){const t=r.map((t=>t[Symbol.asyncIterator]()));for(;;){const e=await Promise.all(t.map((t=>t.next())));if(e.some((t=>t.done)))break;yield e.map((t=>t.value))}},e}each(t=void 0){if(void 0===t)return s.each(...this);const e=this,r=new s;return r[Symbol.asyncIterator]=async function*(){for await(const r of e)for await(const e of s.as(t))yield[r,e]},r}static each(...t){const e=t.map((t=>s.as(t)));return a.as((t=>{if(t.length>=e.length)return s.of();const r=e[t.length],n=new s;return n[Symbol.asyncIterator]=async function*(){for await(const e of r)yield t.add(e)},n}))}self(){return s.self(this)}static self(t){const e=s.as(t),r=new s;return r[Symbol.asyncIterator]=async function*(){for(;;)yield e},r}async what(t,e){return s.what(this,t,e)}static async what(t,e,r){const n=s.as(t);if(e){let t=void 0!==r;for await(const s of n)t?r=await e(r,s):(r=s,t=!0);return r}for await(const t of n)return t}}class n{static matches(t,e){if("function"==typeof e)try{return e(t)}catch(t){return!1}if(null==t)return!1;if(t===e)return!0;if(t instanceof Error)return this.matches(t.constructor.name,e)||this.matches(t.statusCode,e)||this.matches(t.message,e);if("string"==typeof t){if("string"==typeof e)return t.includes(e);if(e instanceof RegExp)return e.test(t)}return!1}}class i extends Error{constructor(t,e="Operation timed out",r){super(e),this.millis=t,this.name=this.constructor.name,r&&(this.cause=r)}}class o{static of(...t){const e=t.slice(0,-1),r=t.at(-1);return o.as((async(...t)=>await s.equal(e,t)?r:void 0))}static as(t){if(t instanceof o)return t;if("function"!=typeof t){const e=t;t=async()=>e}const e=async(...e)=>await t(...e);return Object.setPrototypeOf(e,o.prototype),e.what=t.bind(e),e}static retype(t,e){return Object.setPrototypeOf(t,Object.getPrototypeOf(e)),t}if(t=async t=>void 0!==t,e=void 0){return o.retype(o.if(t,this,e),this)}static if(t,e,r=void 0){return o.as((async(...s)=>{if(await t(...s))return await e(...s);throw r}))}sthen(...t){return o.retype(o.sthen(this,...t),this)}static sthen(...t){return o.as((async e=>{let r=e;for(let e of t)r=await e(r);return r}))}else(t,e=void 0){return t=o.as(t),o.retype((async(...r)=>{let s;try{s=await this(...r)}catch(s){if(!e||n.matches(s,e))return await t(...r,s);throw s}return void 0===s?await t(...r):s}),this)}which(t=async t=>void 0!==t,e=void 0){return o.retype(o.which(this,t,e),this)}static which(t,e=async t=>void 0!==t,r=void 0){return o.as((async(...s)=>{const n=await t(...s);if(await e(n,...s))return n;if(void 0!==r)throw r}))}when(t,e,r,s=void 0,n=!0){return o.when(t,this,e,r,s,n)}static when(t,e,r,s,n,a=!0){const c=o.as((async(...o)=>(a||e(...o),new Promise(((o,c)=>{let h;const l=async(...s)=>{try{await t(...s,r)&&(u(),e.stopped=!a,a?o(await e(...s,r)):o())}catch(t){u(),c(t)}},u=()=>{h&&clearTimeout(h),"function"==typeof r.off?r.off(s,l):"function"==typeof r.removeEventListener&&r.removeEventListener(s,l)};if("function"==typeof r.on)r.on(s,l);else{if("function"!=typeof r.addEventListener)throw new Error("Unsupported emitter type");r.addEventListener(s,l)}n>0&&(h=setTimeout((()=>{u(),c(new i(`Event "${s}" timed out after ${n}ms`))}),n))})))));return Object.defineProperty(c,"stopped",{get:()=>e.stopped,set:t=>e.stopped=t}),c}match(...t){return o.retype(o.match(this,...t),this)}static match(...t){const e=t.length<2?async e=>[e,await t[0](e)]:async e=>{const r=[];for(let s of t)r.push(await s(e));return r};return o.as(e)}each(t){return o.retype((async(...e)=>await s.as(await this(...e)).which().sthen(t).which().else().toArray()),this)}static each(...t){return o.as((async e=>{const n=e instanceof r?e:r.of(e);return n.length>t.length?c.of():n.across(await s.as(await o.as(t[n.length-1])(n.last)).which().toArray()).which()}))}self(...t){return o.retype(o.self(this,...t),this)}static self(t,...e){let r;if(0===e.length)return r=async e=>e.across(await s.as(await t(e.last)).which().toArray()),o.as(r);if("number"!=typeof e[0]){const[r,s]=e;return o.nominal(t,r,s)}if(1===e.length)return o.within(e[0],t);if(2===e.length){const[r,s]=e;return o.partial(t,r,s)}return o.retry(t,...e)}static partial(t,e,r){return o.as((async(...s)=>t(...s.slice(0,e),r,...s.slice(e))))}static nominal(t,e,r){let n;return n=void 0===e?async(...e)=>{const s=await t(...e);if(void 0===s)return;const n={};return n[r]=s,n}:async n=>{const i=await s.as("string"==typeof e?[e]:e).sthen((t=>"string"==typeof t?n[t]:t)).toArray(),o=await("string"==typeof t?n[t]:t)(...i);return void 0!==r?(n[r]=o,n):o},o.as(n)}static within(t,e,r=new i(`Operation timed out after ${t}ms`)){return o.as((async s=>{let n;try{return await Promise.race([e(s),new Promise(((e,s)=>{n=setTimeout((()=>s(r)),t)}))])}finally{clearTimeout(n)}}))}static retry(t,e=1/0,r=100,s=1,n=1/0){let i=!1;const a=o.as((async o=>{let a=0,c=null;for(;!i&&a<e;)try{const e=await t(o);if(void 0===e)throw new Error("AsyncWhat.retry: undefined result (will retry)");return e}catch(t){c=t;const e=Math.min(r*s**a,n);await new Promise((t=>setTimeout(t,e))),a++}throw i?new Error("Retry stopped by user"):c}));return Object.defineProperty(a,"stopped",{get:()=>i,set:t=>{i=Boolean(t)}}),a}}class a{static of(...t){const e=t.slice(0,-1),r=t.at(-1);return a.as(((...t)=>c.equal(e,t)?r:void 0))}static as(t){if(t instanceof a)return t;if("function"!=typeof t){const e=t;t=()=>e}const e=(...e)=>t(...e);return Object.setPrototypeOf(e,a.prototype),e.what=t.bind(e),e}static retype(t,e){return Object.setPrototypeOf(t,Object.getPrototypeOf(e)),t}if(t=t=>void 0!==t,e=void 0){return a.retype(a.if(t,this,e),this)}static if(t,e,r=void 0){return a.as(((...s)=>{if(t(...s))return e(...s);if(void 0!==r)throw r}))}sthen(t){return a.retype(a.sthen(this,t),this)}static sthen(...t){return a.as((e=>{let r=e;for(let e of t)r=e(r);return r}))}else(t,e){return t=a.as(t),a.retype(((...r)=>{let s;try{s=this(...r)}catch(s){if(!e||n.matches(s,e))return t(...r,s);throw s}return void 0===s?t(...r):s}),this)}which(t=t=>void 0!==t,e=a.WHICH_ERROR){return a.retype(a.which(this,t,e),this)}static which(t,e=t=>void 0!==t,r=void 0){return a.as(((...s)=>{const n=t(...s);if(e(n,...s))return n;if(void 0!==r)throw r}))}when(t,e,r,s=void 0,n=!0){return o.when(t,this,e,r,s,n)}match(...t){return a.retype(a.match(this,...t),this)}static match(...t){const e=t.length<2?e=>[e,t[0](e)]:e=>t.map((t=>t(e)));return a.as(e)}each(t){return a.retype(((...e)=>c.as(this(...e)).which().sthen(t).which().else()),this)}static each(...t){return a.as((e=>{const s=e instanceof r?e:r.of(e);return s.length>t.length?c.of():s.across(c.as(a.as(t[s.length-1])(s.last)).which()).which()}))}self(...t){return a.retype(a.self(this,...t),this)}static self(t,...e){let r;if(0===e.length)return r=e=>e.across(c.as(t(e.last)).which().toArray()),a.as(r);if("number"!=typeof e[0]){const[r,s]=e;return a.nominal(t,r,s)}if(2===e.length){const[r,s]=e;return a.partial(t,r,s)}return o.self(t,...e)}static partial(t,e,r){return a.as(((...s)=>t(...s.slice(0,e),r,...s.slice(e))))}static nominal(t,e,r){let s;return s=void 0===e?(...e)=>{const s=t(...e);if(void 0===s)return;const n={};return n[r]=s,n}:s=>{const n=c.as("string"==typeof e?[e]:e).sthen((t=>"string"==typeof t?s[t]:t)).toArray(),i=("string"==typeof t?s[t]:t)(...n);return void 0!==r?(s[r]=i,s):i},a.as(s)}}class c{[Symbol.iterator](){throw"abstract method!"}static as(t){if(void 0===t)return c.of();if(t instanceof c)return t;if(t[Symbol.iterator]){const e=new c;return e[Symbol.iterator]=t[Symbol.iterator].bind(t),e}{const e=new c;return e[Symbol.iterator]=function*(){yield t},e}}static of(...t){const e=new c;return e[Symbol.iterator]=function*(){for(const e of t)yield e},e}static along(t,e){const r=new c;return r[Symbol.iterator]=function*(){let r=t;for(;r;)yield r,r=e(r)},r}toArray(){return Array.from(this)}equals(t){return c.equal(this,t)}static equal(t,e){if("string"==typeof t||!c.isIterable(t)||"string"==typeof e||!c.isIterable(e))return t===e;{const r=t[Symbol.iterator](),s=e[Symbol.iterator]();for(;;){const t=r.next(),e=s.next();if(t.done||e.done)return t.done===e.done;if(!c.equal(t.value,e.value))return!1}}}static isIterable(t){return null!=t&&"function"==typeof t[Symbol.iterator]}if(t=t=>void 0!==t){return c.if(this,t)}static if(t,e=t=>void 0!==t){return c.which(t,e)}sthen(t){return c.sthen(this,t)}static sthen(t,e){const r=new c;return r[Symbol.iterator]=function*(){let r=0;for(let s of t)yield e(s,r++)},r}else(t=void 0){return void 0===t?c.else(this):c.else(c.of(this,c.as(t)))}static else(t){const e=new c;return e[Symbol.iterator]=function*(){for(let e of t)if(e[Symbol.iterator])for(let t of e)yield t;else yield e},e}which(t=t=>void 0!==t){return c.which(this,t)}static which(t,e=t=>void 0!==t){const r=new c;return r[Symbol.iterator]=function*(){let r=0;for(let s of t)e(s,r++)&&(yield s)},r}when(t,e=!0,r=e){return c.when(this,t,e,r)}static when(t,e,r=!0,n=r){if(void 0===e){const e={};return e[Symbol.asyncIterator]=async function*(){for(const e of t)yield await e},s.as(e)}if("number"==typeof e){const t=e;e=(e,r)=>r===t}const i=new c;return i[Symbol.iterator]=r?function*(){let r=0,s=!1;for(let i of t)s?yield i:e(i,r)&&(s=!0,n&&(yield i)),r++}:function*(){let r=0,s=!1;for(let i of t){if(s)break;e(i,r)?(s=!0,n&&(yield i)):yield i,r++}},i}match(t=void 0){return void 0===t?c.match(...this):c.match(this,c.as(t))}static match(...t){const e=new c;return e[Symbol.iterator]=function*(){const e=t.map((t=>t[Symbol.iterator]()));for(;;){const t=e.map((t=>t.next()));if(t.some((t=>t.done)))break;yield t.map((t=>t.value))}},e}each(t=void 0){if(void 0===t)return c.each(...this);const e=this,r=new c;return r[Symbol.iterator]=function*(){for(let r of e)for(let e of c.as(t))yield[r,e]},r}static each(...t){return t=t.map((t=>t[Symbol.iterator]?t:[t])),a.as((e=>e.length<t.length?e.across(t[e.length]):c.of()))}self(){return c.self(this)}static self(t){const e=new c;return e[Symbol.iterator]=function*(){for(;;)yield t},e}what(t=void 0,e=void 0){return c.what(this,t,e)}static what(t,e,r){if(e){void 0===r&&(r=c.what(t),t=c.when(t,1));for(let s of t)r=e(r,s);return r}for(let e of t)return e}}c.NATURAL=new c,c.NATURAL[Symbol.iterator]=function*(){let t=0;for(;;)yield t++};class h extends c{constructor(){super()}n(){throw new Error("Abstract method: n()")}has(t){throw new Error("Abstract method: has(item)")}add(t){throw new Error("Abstract method: add(item)")}remove(t){throw new Error("Abstract method: remove(item)")}clear(){throw new Error("Abstract method: clear()")}get(t){throw new Error("Abstract method: get(query)")}[Symbol.iterator](){throw new Error("Abstract method: Symbol.iterator()")}create(t){return!this.has(t)&&this.add(t)}read(t){return this.has(t)?c.as(this.get(t)).what():void 0}readAll(t){return this.get(t)}update(t,e,r=!1){return this.has(t)?this.remove(t)&&this.add(e):!!r&&this.add(e)}delete(t){return this.remove(t)}deleteAll(t){return this.removeAll(t)}query(t){return this.get(t)}get size(){return this.n()}isEmpty(){return 0===this.n()}let(t){return this.add(t),this}addAll(t){const e=[];for(const r of t)this.add(r)&&e.push(r);return this}removeAll(t){const e=[];for(const r of t)this.remove(r)&&e.push(r);return e}}class l extends s{constructor(){super()}async n(){throw new Error("Abstract method: n()")}async has(t){throw new Error("Abstract method: has(item)")}async add(t){throw new Error("Abstract method: add(item)")}async remove(t){throw new Error("Abstract method: remove(item)")}async clear(){throw new Error("Abstract method: clear()")}get(t){throw new Error("Abstract method: get(query)")}[Symbol.asyncIterator](){throw new Error("Abstract method: Symbol.asyncIterator()")}async create(t){return!await this.has(t)&&this.add(t)}async read(t){if(await this.has(t))for await(const e of this.get(t))return e}readAll(t){return this.get(t)}async update(t,e,r=!1){return await this.has(t)?await this.remove(t)&&await this.add(e):!!r&&this.add(e)}async delete(t){return this.remove(t)}async deleteAll(t){return this.removeAll(t)}query(t){return this.get(t)}async isEmpty(){return 0===await this.n()}async addAll(t){const e=[];for await(const r of t)await this.add(r)&&e.push(r);return e}async removeAll(t){const e=[];for await(const r of t)await this.remove(r)&&e.push(r);return e}}class u extends h{constructor(){super()}peek(t=!0){throw new Error("Abstract method: peek() must be implemented by subclass.")}poll(t=!0){const e=this.peek(t);return this.remove(e),e}reverse(){throw new Error("Abstract method: reverse() must be implemented by subclass.")}select(t,e=!0){t<0&&(t=0);const r=this.n()-t,s=new Array(r<0?0:r).fill(void 0);let n=e?s.length-1:0;const i=e?-1:1;for(;this.n()>t;){const t=this.poll(!e);s[n]=t,n+=i}return s}}class f extends u{constructor(t=!0,e=[]){super(),this._fifo=t,this._items=e}get fifo(){return this._fifo}get items(){return this._items}n(){return this.items.length}has(t){return!1}add(t){return this.items.push(t),!0}remove(t){return!1}peek(t=!0){return this.items[this.index(t)]}poll(t=!0){return 0===this.index(t)?this.items.shift():this.items.pop()}index(t){return this.fifo?t?0:this.items.length-1:t?this.items.length-1:0}clear(){return this.items.length=0,!0}[Symbol.iterator](){return this.items[Symbol.iterator]()}reverse(){const t=new c,e=this;return t[Symbol.iterator]=function*(){let t=e.items.length-1;for(;t>=0;)yield e.items[t],t--},t}}const y={ASCENDING:(t,e)=>t<e?-1:t===e?0:1,DESCENDING:(t,e)=>t<e?1:t===e?0:-1,INSERTION:void 0,SINGULAR:(t,e)=>0,BY_PROPERTY:(t,e=y.ASCENDING)=>(r,s)=>{const n=r?.[t],i=s?.[t];return e(n,i)},REVERSE:t=>(e,r)=>-t(e,r)},d={BY_DEPTH:(t,e)=>(Array.isArray(t)||(t=[t]),Array.isArray(e)||(e=[e]),r=>[t[r.depth]??t[t.length-1],e[r.depth]??e[e.length-1]]),UNIFORM:(t,e)=>()=>[t,e]};class m extends f{constructor(t=y.ASCENDING,e=[]){super(!0,[]),this._comparator=t,this._items=[];for(const t of e)this.add(t)}get items(){return this._items}get comparator(){return this._comparator}has(t){const[e,r]=m.logSearch(t,this.items,this.comparator);return void 0!==r}add(t){const[e,r]=m.logSearch(t,this.items,this.comparator);return void 0===r&&(this.items.splice(e,0,t),!0)}remove(t){const[e,r]=m.logSearch(t,this.items,this.comparator);return void 0!==r&&(this.items.splice(e,1),!0)}static logSearch(t,e,r,s=0,n=e.length){for(;s<n;){const i=s+n>>>1,o=r(e[i],t);if(0===o)return[i,e[i]];o<0?s=i+1:n=i}return[s,void 0]}}class w extends u{constructor(t=d.UNIFORM(y.ASCENDING,y.INSERTION),e=null,r=void 0){super(),this.parent=e,this.key=r,this.sorter=t,this.depth=(e?.depth??-1)+1,this.nin=0,this.nout=0;const[s,n]=t(this);this.sortedKeys=new m(s),this.keyToChild=new Map,this.class="function"==typeof n?new m(n):new f(n)}getChild(t,e=!1){let r=this.keyToChild.get(t);return!r&&e&&(r=new w(this.sorter,this,t),this.keyToChild.set(t,r),this.sortedKeys.add(t)),r}with(t,e=!1){let r=this;for(const s of t)if(r=r.getChild(s,e),!r)return;return r}increment(t=1){this.nin+=t;let e=this.parent;for(;e;)e.nout+=t,e=e.parent}pruneIfEmpty(){let t=this;for(;t.parent&&0===t.nin&&0===t.nout;){const e=t.parent;e.keyToChild.delete(t.key),e.sortedKeys.remove(t.key),t.parent=null,t.depth=0,t=e}}n(){return this.nin+this.nout}get size(){return this.nin+this.nout}has(t){const e=this.with(t);return void 0!==e&&e.nin>0}add(t,e,r=1){const s=this.with(t,r>0);if(!s)return!1;const n=s.class.add(e);return s.increment(r),s.pruneIfEmpty(),n}remove(t,e=1/0){const r=this.with(t);return!!r&&(r.increment(-Math.min(e,r.nin)),r.pruneIfEmpty(),!0)}clear(){this.nin=0,this.nout=0,this.sortedKeys.clear(),this.keyToChild.clear(),this.class.clear(),this.pruneIfEmpty()}get(t,e=!0){return c.else(this.descendants(t,e).sthen((t=>e?t.class:t.class.reverse())))}reverse(){return this.get([],!1)}peek(t=!0){return this.get([],t).what()}path(){return this.parent?this.parent.path().add(this):new r}*[Symbol.iterator](){yield*this.get([],!0)}descendants(t=[],e=!0,r=0){Array.isArray(t)||(t=c.as(t).toArray());const s=this;return c.as(function*(){const n=e?s.sortedKeys:[...s.sortedKeys].reverse(),i=t[r];for(const o of n){if(void 0!==i&&o!==i)continue;const n=s.keyToChild.get(o);n&&(yield n,yield*n.descendants(t,e,r+1))}}())}*keys(){for(const t of this.descendants())t.nin>0&&(yield t.path().toArray().map((t=>t.key)))}*values(){for(const t of this.descendants())yield*t.class}*entries(){for(const t of this.descendants()){if(t.nin<=0)continue;const e=t.path().toArray().map((t=>t.key));for(const r of t.class)yield[e,r]}}}class p extends u{constructor(t,e=new w){super(),this.repr=e=>c.as(t(e)),this.classifier=e}[Symbol.iterator](){return this.classifier.values()}n(){return this.classifier.n()}has(t){return this.classifier.has(this.repr(t))}add(t,e=1){return this.classifier.add(this.repr(t),t,e),this}remove(t,e=1/0){return this.classifier.remove(this.repr(t),e)}clear(){this.classifier.clear()}get(t,e=!0){return this.classifier.get(this.repr(t),e)}peek(t=!0){return this.classifier.peek(t)}reverse(){return this.classifier.values(!1)}}return e})()));